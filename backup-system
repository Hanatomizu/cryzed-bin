#!/usr/bin/env python

import argparse
import itertools
import os
import pwd
import re
import sys
from datetime import datetime

from plumbum import local
from plumbum.cmd import pacman, awk, tar, lostfiles

argument_parser = argparse.ArgumentParser()
argument_parser.add_argument('--destination', default=os.getcwd())

BLACKLIST = (
    re.compile(re.escape('/etc/gconf')),
    re.compile(re.escape('/etc/gtk-2.0')),
    re.compile(re.escape('/opt')),
    re.compile(re.escape('/usr'))
)

OUTPUT_FILE_NAME = 'backup-%s-%s.tar.gz' % (os.uname().nodename, datetime.now().strftime('%Y-%d-%m_%H-%M'))
PACMAN_EXPLICITLY_INSTALLED_PACKAGES_FILE_NAME = 'pacman-explicitly-installed-packages.txt'
SYSTEMD_OCTOR_FILE_NAME = 'systemd-unit-files.json'


def find_paths(path, predicate=lambda path: True, recursive=True, follow_symlinks=True):
    """
    Yields absolute paths in path that fulfill the predicate.

    If recursive is True all paths below path will be traversed. If follow_symlinks is True symbolic links will be
    followed.
    """

    for root, directories, filenames in os.walk(path, followlinks=follow_symlinks):
        for name in itertools.chain(directories, filenames, (root,)):
            path = os.path.join(root, name)
            if predicate(path):
                yield path

        if not recursive:
            break


def get_explicitly_installed_packages():
    return pacman('-Q', '--explicit')


def get_modified_backup_files_paths():
    # https://wiki.archlinux.org/index.php/Pacman/Tips_and_tricks#Listing_changed_backup_files
    return [l for l in (pacman['-Qii'] | awk['/^MODIFIED/ {print $2}'])().splitlines() if l.strip()]


def get_lost_files_paths():
    # https://aur.archlinux.org/packages/lostfiles/
    return [l for l in lostfiles('strict').splitlines() if l.strip()]


def blacklisted(path):
    return any(entry.match(path) for entry in BLACKLIST)


def is_dotfile(path):
    return os.path.basename(path).startswith('.')


def main(arguments):
    uid = os.getuid()
    if not uid == 0:
        print('This script must be run as root!', file=sys.stderr)
        return 1

    root = pwd.getpwuid(uid)

    # Write list of explicitly installed packages
    path = os.path.join(root.pw_dir, PACMAN_EXPLICITLY_INSTALLED_PACKAGES_FILE_NAME)
    with open(path, 'w') as file:
        file.write(get_explicitly_installed_packages())
    remove = [path]

    # Write systemd-octor systemd configuration json
    path = os.path.join(root.pw_dir, SYSTEMD_OCTOR_FILE_NAME)
    local['systemd-octor']('--destination', path)
    remove.append(path)

    backup_paths = [p for p in get_modified_backup_files_paths() if os.path.isfile(p) and not blacklisted(p)]
    backup_paths.extend([p for p in get_lost_files_paths() if os.path.isfile(p) and not blacklisted(p)])
    backup_paths.append(root.pw_dir)

    # TODO: Find all interactive users and use pw_dirs explicitly?
    # Only backup dotfiles for all users
    user_homes = os.listdir('/home')
    for user_home in user_homes:
        dotfile_paths = find_paths(os.path.join('/home', user_home), is_dotfile, recursive=False)
        backup_paths.extend(dotfile_paths)

    output_path = os.path.join(arguments.destination, OUTPUT_FILE_NAME)
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    tar('--create', '--auto-compress', '--directory', '/', '--file', output_path, *backup_paths, retcode=(0, 1))

    # Remove temporary files
    for path in remove:
        os.remove(path)


if __name__ == '__main__':
    arguments = argument_parser.parse_args()
    main(arguments)
